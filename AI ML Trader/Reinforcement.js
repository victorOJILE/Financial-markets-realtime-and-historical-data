import numpy as np
import pandas as pd
import math
import random
import json
from datetime
import datetime
import gym
from gym
import spaces

class MarketEnv:
    # Gym - style trading environment
for discrete actions.

# Observation(state): window x features numpy array(float32) where features are
#[open, high, low, close, (optional) volume, returns, atr]

# Actions(discrete):
    # 0 - Hold(do nothing)
# 1 - Open / maintain Long(buy)
# 2 - Open / maintain Short(sell)
# 3 - Close position(
    if any)



def __init__(self,
    data,
    window = 200,
    initial_balance = 100000.0,
    max_position_fraction = 0.2,
    lot_size_per_unit = 1.0,
    spread_pips = 0.2,
    slippage_volatility_coef = 0.5,
    commission_per_trade = 0.0,
    risk_penalty_lambda = 0.0,
    vol_penalty_lambda = 0.0,
    drawdown_penalty_lambda = 1.0,
    max_daily_loss_fraction = 0.02): \"\"\"\n        data: pd.DataFrame or numpy array with columns ['open','high','low','close'] (and optional 'volume','time')\n        window: number of candles in observation window\n        initial_balance: starting equity\n        max_position_fraction: max fraction of equity to risk on a single trade\n        spread_pips: baseline spread in price units (same units as price; e.g., for XAUUSD use 0.2)\n        slippage_volatility_coef: multiplier used to compute slippage as function of recent volatility\n        commission_per_trade: fixed commission charged per trade\n        risk_penalty_lambda, vol_penalty_lambda, drawdown_penalty_lambda: reward regularizers\n        max_daily_loss_fraction: hard stop for daily realized loss\n        \"\"\"\n        # Normalize data into numpy array format\n        if isinstance(data, pd.DataFrame):\n            df = data.copy()\n        else:\n            # assume numpy array shape (N,4) in [open,high,low,close]\n            df = pd.DataFrame(data, columns=['open','high','low','close'])\n\n        # required columns\n        for col in ['open','high','low','close']:\n            if col not in df.columns:\n                raise ValueError(f\"Data must contain column '{col}'\")\n\n        self.df = df.reset_index(drop=True)\n        self.prices = self.df[['open','high','low','close']].values.astype(float)\n        self.window = window\n        self.initial_balance = float(initial_balance)\n        self.equity = float(initial_balance)\n        self.cash = float(initial_balance)\n        self.position = None  # dict: {'side': 'long'/'short', 'size': fraction_of_equity, 'entry_price': float, 'units': float}\n        self.max_position_fraction = float(max_position_fraction)\n        self.lot_size_per_unit = float(lot_size_per_unit)\n        self.spread_pips = float(spread_pips)\n        self.slippage_volatility_coef = float(slippage_volatility_coef)\n        self.commission_per_trade = float(commission_per_trade)\n        self.risk_penalty_lambda = float(risk_penalty_lambda)\n        self.vol_penalty_lambda = float(vol_penalty_lambda)\n        self.drawdown_penalty_lambda = float(drawdown_penalty_lambda)\n        self.max_daily_loss_fraction = float(max_daily_loss_fraction)\n\n        # tracking\n        self.current_step = self.window\n        self.done = False\n        self.peak_equity = self.equity\n        self.starting_balance = self.equity\n        self.daily_start_balance = self.equity\n        self.realized_pnl_today = 0.0\n        self.trade_count = 0\n        self._compute_aux_arrays()\n\n        # gym spaces (optional)\n        if spaces is not None:\n            obs_shape = (self.window, self._n_features)\n            self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=obs_shape, dtype=np.float32)\n            self.action_space = spaces.Discrete(4)\n\n    def _compute_aux_arrays(self):\n        # Compute returns and ATR for reward shaping / slippage\n        close = self.prices[:,3]\n        returns = np.zeros_like(close)\n        returns[1:] = (close[1:] - close[:-1]) / (close[:-1] + 1e-12)\n        self.returns = returns\n        # ATR-like measure (simple True Range rolling mean)\n        high = self.prices[:,1]\n        low = self.prices[:,2]\n        tr = np.maximum(high - low, np.maximum(np.abs(high - close), np.abs(low - close)))\n        # rolling mean TR over window 14\n        atr = pd.Series(tr).rolling(window=14, min_periods=1).mean().fillna(method='bfill').values\n        self.atr = atr\n        # simple volatility (std of returns over 20)\n        vol = pd.Series(returns).rolling(window=20, min_periods=1).std().fillna(0).values\n        self.vol = vol\n        self._n_features = 4 + 2  # basic features + returns + atr (you can expand)\n\n    def reset(self, start_index=None):\n        if start_index is None:\n            # pick random safe start between window and len-data-2\n            start_index = random.randint(self.window, max(self.window, len(self.prices)-2))\n        self.current_step = int(start_index)\n        self.equity = float(self.initial_balance)\n        self.cash = float(self.initial_balance)\n        self.position = None\n        self.peak_equity = self.equity\n        self.starting_balance = self.equity\n        self.daily_start_balance = self.equity\n        self.realized_pnl_today = 0.0\n        self.trade_count = 0\n        self.done = False\n        return self._get_observation()\n\n    def _get_observation(self):\n        # Build features for last window candles\n        i = int(self.current_step)\n        start = i - self.window\n        slice_prices = self.prices[start:i]\n        # features: open, high, low, close, return, atr\n        returns_slice = self.returns[start:i].reshape(-1,1)\n        atr_slice = self.atr[start:i].reshape(-1,1)\n        obs = np.concatenate([slice_prices, returns_slice, atr_slice], axis=1).astype(np.float32)\n        return obs\n\n    def _get_spread(self, step_index):\n        # For now, return fixed spread; can be time-of-day dependent\n        return self.spread_pips\n\n    def _get_slippage(self, step_index, volume_fraction):\n        # slippage scales with recent volatility and order size\n        vol = self.vol[step_index]\n        slippage = self.slippage_volatility_coef * vol * (1.0 + volume_fraction)\n        # add small noise\n        slippage *= (1.0 + np.random.normal(0, 0.1))\n        return abs(slippage)\n\n    def step(self, action):\n        if self.done:\n            raise RuntimeError(\"Step called after done=True. Call reset().\")\n\n        info = {}\n        prev_equity = self.equity\n        executed = False\n        trade_costs = 0.0\n        realized_pnl = 0.0\n\n        # Next price used for execution is next candle's open\n        exec_price = float(self.prices[self.current_step, 0])\n\n        # Determine spread and slippage\n        spread = self._get_spread(self.current_step)\n\n        # Interpret action\n        if action == 0:  # Hold\n            pass\n        elif action == 1:  # Open / maintain Long\n            if self.position is None or self.position['side'] != 'long':\n                # open new long with fraction of equity\n                fraction = self.max_position_fraction\n                # compute slippage\n                slip = self._get_slippage(self.current_step, fraction)\n                entry_price = exec_price + spread/2.0 + slip\n                units = (self.equity * fraction) / entry_price\n                self.position = {'side':'long', 'size':fraction, 'entry_price':entry_price, 'units':units}\n                executed = True\n                trade_costs += abs(spread/2.0) + abs(slip) + self.commission_per_trade\n                self.trade_count += 1\n        elif action == 2:  # Open / maintain Short\n            if self.position is None or self.position['side'] != 'short':\n                fraction = self.max_position_fraction\n                slip = self._get_slippage(self.current_step, fraction)\n                entry_price = exec_price - spread/2.0 - slip\n                units = (self.equity * fraction) / entry_price\n                self.position = {'side':'short', 'size':fraction, 'entry_price':entry_price, 'units':units}\n                executed = True\n                trade_costs += abs(spread/2.0) + abs(slip) + self.commission_per_trade\n                self.trade_count += 1\n        elif action == 3:  # Close position\n            if self.position is not None:\n                # close at next open minus spread/slippage\n                pos = self.position\n                if pos['side'] == 'long':\n                    close_price = exec_price - spread/2.0 - self._get_slippage(self.current_step, pos['size'])\n                    pnl = (close_price - pos['entry_price']) * pos['units']\n                else:\n                    close_price = exec_price + spread/2.0 + self._get_slippage(self.current_step, pos['size'])\n                    pnl = (pos['entry_price'] - close_price) * pos['units']\n                realized_pnl += pnl\n                self.equity += pnl\n                self.realized_pnl_today += pnl\n                trade_costs += self.commission_per_trade + abs(spread/2.0)\n                self.position = None\n                executed = True\n                self.trade_count += 1\n        else:\n            raise ValueError('Invalid action')\n\n        # Advance environment one step (market moves to next candle)\n        self.current_step += 1\n        # Update unrealized PnL if position exists (mark-to-market)\n        if self.position is not None:\n            pos = self.position\n            # mark to close of current_step (we advanced already, so refer to current index)\n            price_index = min(self.current_step, len(self.prices)-1)\n            mark_price = float(self.prices[price_index, 3])\n            if pos['side'] == 'long':\n                unreal_pnl = (mark_price - pos['entry_price']) * pos['units']\n            else:\n                unreal_pnl = (pos['entry_price'] - mark_price) * pos['units']\n            # equity includes unrealized pnl\n            self.equity = self.cash + unreal_pnl\n        else:\n            # no position\n            pass\n\n        # Apply trade costs and realized pnl (if any)\n        self.equity -= trade_costs\n\n        # Update peak equity\n        if self.equity > self.peak_equity:\n            self.peak_equity = self.equity\n\n        # Compute reward\n        delta_equity = self.equity - prev_equity\n        vol_penalty = self.vol_penalty_lambda * self.vol[self.current_step] if self.current_step < len(self.vol) else 0.0\n        drawdown = (self.peak_equity - self.equity) / (self.peak_equity + 1e-12)\n        draw_penalty = self.drawdown_penalty_lambda * max(0.0, drawdown)\n        risk_penalty = self.risk_penalty_lambda * (self.position['size']**2 if self.position is not None else 0.0)\n\n        reward = delta_equity - trade_costs - vol_penalty - draw_penalty - risk_penalty\n\n        # check terminal conditions\n        done = False\n        info['executed'] = executed\n        info['trade_costs'] = trade_costs\n        info['realized_pnl'] = realized_pnl\n        info['equity'] = self.equity\n        info['position'] = self.position\n        info['trade_count'] = self.trade_count\n\n        # daily loss check\n        if self.realized_pnl_today <= -abs(self.max_daily_loss_fraction * self.starting_balance):\n            done = True\n            info['reason'] = 'daily_loss_limit'\n\n        # if we run out of price data\n        if self.current_step >= len(self.prices)-1:\n            done = True\n            info['reason'] = info.get('reason', 'end_of_data')\n\n        self.done = done\n        return self._get_observation(), float(reward), bool(done), info\n\n    def seed(self, s=None):\n        random.seed(s)\n        np.random.seed(s)\n\n    def render(self, mode='human'):\n        print(f\"Step: {self.current_step}, Equity: {self.equity:.2f}, Peak: {self.peak_equity:.2f}, Position: {self.position}\")\n\n\nif __name__ == '__main__':\n    # Quick sanity test using synthetic price series (sinusoidal + trend)\n    import os\n    length = 2000\n    t = np.arange(length)\n    base = 1800.0\n    # synthetic price with trend + noise\n    price_series = base + 5.0 * np.sin(0.01*t) + 0.002 * t + np.random.normal(0, 0.5, size=length)\n    # build OHLC from synthetic close (simple replication)\n    close = price_series\n    open_p = np.concatenate([[price_series[0]], price_series[:-1]])\n    high = np.maximum(open_p, close) + np.random.random(size=length)*0.5\n    low = np.minimum(open_p, close) - np.random.random(size=length)*0.5\n    df = pd.DataFrame({'open':open_p, 'high':high, 'low':low, 'close':close})\n\n    env = MarketEnv(df, window=200)\n    obs = env.reset(start_index=300)\n    cumulative_reward = 0.0\n    steps = 200\n    for step in range(steps):\n        action = random.choice([0,1,2,3])\n        obs, reward, done, info = env.step(action)\n        cumulative_reward += reward\n        if step % 20 == 0:\n            print(f\"Step {step}: action={action}, reward={reward:.2f}, equity={info['equity']:.2f}, executed={info['executed']}\")\n        if done:\n            print(\"Episode done, reason:\", info.get('reason'))\n            break\n    print(f\"Cumulative reward (random policy) for {step+1} steps: {cumulative_reward:.2f}\")\n"
""

file_path = "/mnt/data/market_env.py"
with open(file_path, "w") as f:
    f.write(module_code)

# Show confirmation and head of file
with open(file_path, "r") as f:
    head = f.read(800)

file_path, head[: 800]